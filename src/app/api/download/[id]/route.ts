import { NextRequest, NextResponse } from 'next/server';
import { mockDb } from '@/lib/mockDb';
import * as fs from 'fs/promises';
import * as path from 'path';

export async function GET(
  request: NextRequest,
  { params }: { params: Promise<{ id: string }> }
) {
  try {
    const { id: jobId } = await params;
    const job = mockDb.jobs.get(jobId);

    if (!job) {
      return NextResponse.json(
        { error: 'Job not found' },
        { status: 404 }
      );
    }

    if (job.status !== 'Completed') {
      return NextResponse.json(
        { error: 'Job not completed yet' },
        { status: 400 }
      );
    }

    // Check for the zip file first
    const zipPath = path.join(process.cwd(), 'public', 'downloads', `${jobId}.zip`);
    
    try {
      await fs.access(zipPath);
      const fileBuffer = await fs.readFile(zipPath);
      
      return new NextResponse(fileBuffer, {
        headers: {
          'Content-Type': 'application/zip',
          'Content-Disposition': `attachment; filename="${jobId}-project.zip"`,
          'Content-Length': fileBuffer.length.toString(),
        },
      });
    } catch (error) {
      // If zip doesn't exist, try tar.gz
      const tarPath = path.join(process.cwd(), 'public', 'downloads', `${jobId}.tar.gz`);
      
      try {
        await fs.access(tarPath);
        const fileBuffer = await fs.readFile(tarPath);
        
        return new NextResponse(fileBuffer, {
          headers: {
            'Content-Type': 'application/gzip',
            'Content-Disposition': `attachment; filename="${jobId}-project.tar.gz"`,
            'Content-Length': fileBuffer.length.toString(),
          },
        });
      } catch (error) {
        // Fallback to text file if no archive exists
        const projectName = `sandbox-ai-project-${jobId.replace('job_', '')}.txt`;
        const fileContent = `
Project: ${job.description}
Job ID: ${jobId}
Created At: ${new Date(job.createdAt).toLocaleString()}

This project was generated by the coding agent.
The actual project files should have been packaged, but the archive was not found.

Agent Logs:
${job.logs.map(log => `[${new Date(log.timestamp).toLocaleTimeString()}] [${log.type.toUpperCase()}] ${log.message}`).join('\n')}
        `;

        return new NextResponse(fileContent, {
          headers: {
            'Content-Type': 'text/plain',
            'Content-Disposition': `attachment; filename="${projectName}"`,
          },
        });
      }
    }

  } catch (error) {
    console.error('Error downloading file:', error);
    return NextResponse.json(
      { error: 'Failed to download file' },
      { status: 500 }
    );
  }
}

export async function POST(request: NextRequest) {
  try {
    const { task } = await request.json();
    
    if (!task || typeof task !== 'string') {
      return NextResponse.json(
        { error: 'Task is required and must be a string' },
        { status: 400 }
      );
    }

    const jobId = `job_${uuidv4()}`;
    const job: Job = {
      id: jobId,
      description: task,
      status: 'Queued',
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString(),
      logs: [
        {
          timestamp: new Date().toISOString(),
          message: 'Job scheduled successfully',
          type: 'info'
        }
      ]
    };

    mockDb.jobs.set(jobId, job);

    // Start background job processing
    simulateJobProcessing(jobId);

    return NextResponse.json({ 
      jobId, 
      status: job.status,
      message: 'Job scheduled successfully'
    });
  } catch (error) {
    console.error('Error scheduling job:', error);
    return NextResponse.json(
      { error: 'Failed to schedule job' },
      { status: 500 }
    );
  }
}

async function simulateJobProcessing(jobId: string) {
  // Simulate container provisioning
  setTimeout(() => {
    const job = mockDb.jobs.get(jobId);
    if (job) {
      job.status = 'Provisioning';
      job.logs.push({
        timestamp: new Date().toISOString(),
        message: 'Provisioning sandbox container...',
        type: 'info'
      });
      mockDb.jobs.set(jobId, job);
    }
  }, 2000);

  // Simulate agent starting
  setTimeout(() => {
    const job = mockDb.jobs.get(jobId);
    if (job) {
      job.status = 'Running';
      job.logs.push({
        timestamp: new Date().toISOString(),
        message: 'Container provisioned, starting agent execution',
        type: 'info'
      });
      job.logs.push({
        timestamp: new Date().toISOString(),
        message: 'Analyzing task requirements...',
        type: 'info'
      });
      mockDb.jobs.set(jobId, job);
    }
  }, 5000);

  // Simulate completion
  setTimeout(() => {
    const job = mockDb.jobs.get(jobId);
    if (job) {
      job.status = 'Completed';
      job.downloadUrl = `/api/download/${jobId}`;
      job.logs.push({
        timestamp: new Date().toISOString(),
        message: 'Task completed successfully',
        type: 'success'
      });
      mockDb.jobs.set(jobId, job);
    }
  }, 15000);
}
